{
  "contractName": "LiquidityMath",
  "sourceName": "contracts/src/utils/math/LiquidityMath.sol",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "reserveA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "internalType": "uint24",
          "name": "swapfee",
          "type": "uint24"
        }
      ],
      "name": "computeSwapAmountV2",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "swapAmountA",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "bytecode": "0x608060405234801561001057600080fd5b506103f9806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063896e7cc314610030575b600080fd5b61004361003e3660046102f7565b610055565b60405190815260200160405180910390f35b600061011d61007761006f620f424062ffffff8616610125565b60029061013a565b61011761009687610090621e848062ffffff8916610125565b9061013a565b61011161010c6100c58a6100908b816100b7620f424062ffffff8f16610125565b6100906004620f424061013a565b6101068b6100908d6100906100eb8e62ffffff16621e848061012590919063ffffffff16565b6100908f62ffffff16621e848061012590919063ffffffff16565b90610146565b610152565b90610125565b90610241565b949350505050565b6000610131828461034e565b90505b92915050565b60006101318284610361565b60006101318284610378565b60008160000361016457506000919050565b600060016101718461024d565b901c6001901b9050600181848161018a5761018a61038b565b048201901c905060018184816101a2576101a261038b565b048201901c905060018184816101ba576101ba61038b565b048201901c905060018184816101d2576101d261038b565b048201901c905060018184816101ea576101ea61038b565b048201901c905060018184816102025761020261038b565b048201901c9050600181848161021a5761021a61038b565b048201901c905061023a818285816102345761023461038b565b046102e1565b9392505050565b600061013182846103a1565b600080608083901c1561026257608092831c92015b604083901c1561027457604092831c92015b602083901c1561028657602092831c92015b601083901c1561029857601092831c92015b600883901c156102aa57600892831c92015b600483901c156102bc57600492831c92015b600283901c156102ce57600292831c92015b600183901c156101345760010192915050565b60008183106102f05781610131565b5090919050565b60008060006060848603121561030c57600080fd5b8335925060208401359150604084013562ffffff8116811461032d57600080fd5b809150509250925092565b634e487b7160e01b600052601160045260246000fd5b8181038181111561013457610134610338565b808202811582820484141761013457610134610338565b8082018082111561013457610134610338565b634e487b7160e01b600052601260045260246000fd5b6000826103be57634e487b7160e01b600052601260045260246000fd5b50049056fea2646970667358221220281b96c2a2ec3cfaa4bdc4ca9bf4d539e75437467abca94388e322b5ddceac6f64736f6c63430008120033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063896e7cc314610030575b600080fd5b61004361003e3660046102f7565b610055565b60405190815260200160405180910390f35b600061011d61007761006f620f424062ffffff8616610125565b60029061013a565b61011761009687610090621e848062ffffff8916610125565b9061013a565b61011161010c6100c58a6100908b816100b7620f424062ffffff8f16610125565b6100906004620f424061013a565b6101068b6100908d6100906100eb8e62ffffff16621e848061012590919063ffffffff16565b6100908f62ffffff16621e848061012590919063ffffffff16565b90610146565b610152565b90610125565b90610241565b949350505050565b6000610131828461034e565b90505b92915050565b60006101318284610361565b60006101318284610378565b60008160000361016457506000919050565b600060016101718461024d565b901c6001901b9050600181848161018a5761018a61038b565b048201901c905060018184816101a2576101a261038b565b048201901c905060018184816101ba576101ba61038b565b048201901c905060018184816101d2576101d261038b565b048201901c905060018184816101ea576101ea61038b565b048201901c905060018184816102025761020261038b565b048201901c9050600181848161021a5761021a61038b565b048201901c905061023a818285816102345761023461038b565b046102e1565b9392505050565b600061013182846103a1565b600080608083901c1561026257608092831c92015b604083901c1561027457604092831c92015b602083901c1561028657602092831c92015b601083901c1561029857601092831c92015b600883901c156102aa57600892831c92015b600483901c156102bc57600492831c92015b600283901c156102ce57600292831c92015b600183901c156101345760010192915050565b60008183106102f05781610131565b5090919050565b60008060006060848603121561030c57600080fd5b8335925060208401359150604084013562ffffff8116811461032d57600080fd5b809150509250925092565b634e487b7160e01b600052601160045260246000fd5b8181038181111561013457610134610338565b808202811582820484141761013457610134610338565b8082018082111561013457610134610338565b634e487b7160e01b600052601260045260246000fd5b6000826103be57634e487b7160e01b600052601260045260246000fd5b50049056fea2646970667358221220281b96c2a2ec3cfaa4bdc4ca9bf4d539e75437467abca94388e322b5ddceac6f64736f6c63430008120033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "details": "Liquidity math for computing the optimal one-sided supply to a liquidity pool",
    "kind": "dev",
    "methods": {
      "computeSwapAmountV2(uint256,uint256,uint24)": {
        "details": "Compute swap amount needed for adding liquidity to a pool in the absence of concentrated liquidity (such as a Uniswap V2 pool) The goal is to find the optimal swapAmountA to get a corresponding amount of asset B, so that the proportion of assets the user holds is equal to the proportion of assets in reserves after swap. Calculation: The initial constant product is given by:   k = reserveA * reserveB The swap fee is deducted from the input asset amount, so the new reserveB should satisfy:   k = (reserveA + (1 - fee) * swapA) * reserveB' This means the user will receive an amount of asset B equal to:   rcvAmountB = reserveB - reserveB'              = reserveB - k / (reserveA + (1 - fee) * swapA)              = reserveB - reserveA * reserveB / (reserveA + (1 - fee) * swapAmountA)              = (1 - fee) * reserveB * swapAmountA / (reserveA + (1 - fee) * swapAmountA) The optimal swapAmountA should satisfy the equality constraint on the user's asset ratio and the reserve's asset ratio:   (amountA - swapAmountA) / (reserveA + swapAmountA) = rcvAmountB / reserveB' Substituting known variables rcvAmountB and reserveB' and rearranging the equation yields a quadratic equation in variable swapAmountA as follows:   (1 - fee) * (swapAmountA)^2 + ((2 - fee) * reserveA) * swapAmountA - amountA * reserveA = 0 Solving the above equation for a non-negative root yields:   swapAmountA =     sqrt(((2 - fee) * reserveA)^2 + 4 * (1 - fee) * amountA * reserveA) - (2 - fee) * reserveA       / (2 * (1 - fee)) The fee is represented in hundredths of a bip, so we can avoid floating point numbers by multiplying both the numerator and denominator by 1E6: swapAmountA =   sqrt((2E6 - fee)^2 * reserveA^2 + 4 * 1E6 * (1E6 - fee) * amountA * reserveA) - (2E6 - fee) * reserveA     / (2 * (1E6 - fee)) Credit to Zapper Finance for the above derivation.",
        "params": {
          "amountA": "The amount of token A to add",
          "reserveA": "The reserve of token A",
          "swapfee": "The swap fee of the pool, denominated in hundredths of a bip"
        },
        "returns": {
          "swapAmountA": "The amount of token A to swap for token B"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "203400",
        "executionCost": "245",
        "totalCost": "203645"
      },
      "external": {
        "computeSwapAmountV2(uint256,uint256,uint24)": "infinite"
      }
    },
    "methodIdentifiers": {
      "computeSwapAmountV2(uint256,uint256,uint24)": "896e7cc3"
    }
  }
}